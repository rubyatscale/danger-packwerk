# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `git` gem.
# Please instead update this file by running `bin/tapioca gem git`.

# The Git module provides the basic functions to open a git
# reference to work with. You can open a working directory,
# open a bare repository, initialize a new repo or clone an
# existing remote repository.
#
# @author Scott Chacon (mailto:schacon@gmail.com)
module Git
  # g.config('user.name', 'Scott Chacon') # sets value
  # g.config('user.email', 'email@email.com')  # sets value
  # g.config('user.name')  # returns 'Scott Chacon'
  # g.config # returns whole config hash
  def config(name = T.unsafe(nil), value = T.unsafe(nil)); end

  def global_config(name = T.unsafe(nil), value = T.unsafe(nil)); end

  class << self
    # Open a bare repository
    #
    # Opens a bare repository located in the `git_dir` directory.
    # Since there is no working copy, you can not checkout or commit
    # but you can do most read operations.
    #
    # @example Open a bare repository and retrieve the first commit SHA
    #   repository = Git.bare('ruby-git.git')
    #   puts repository.log[0].sha #=> "64c6fa011d3287bab9158049c85f3e85718854a0"
    # @option options
    # @param git_dir [Pathname] The path to the bare repository directory
    #   containing an initialized Git repository. If a relative path is given, it
    #   is converted to an absolute path using
    #   [File.expand_path](https://www.rubydoc.info/stdlib/core/File.expand_path).
    # @param options [Hash] The options for this command (see list of valid
    #   options below)
    # @return [Git::Base] an object that can execute git commands in the context
    #   of the bare repository.
    # @see https://git-scm.com/docs/gitglossary#Documentation/gitglossary.txt-aiddefbarerepositoryabarerepository What is a bare repository?
    def bare(git_dir, options = T.unsafe(nil)); end

    # Clone a repository into an empty or newly created directory
    #
    # @example Clone into a different directory `my-ruby-git`
    #   git = Git.clone('https://github.com/ruby-git/ruby-git.git', 'my-ruby-git')
    #   # or:
    #   git = Git.clone('https://github.com/ruby-git/ruby-git.git', path: 'my-ruby-git')
    # @example Clone into the default directory `ruby-git`
    #   git = Git.clone('https://github.com/ruby-git/ruby-git.git')
    # @example Create a bare repository in the directory `ruby-git.git`
    #   git = Git.clone('https://github.com/ruby-git/ruby-git.git', bare: true)
    # @example Clone and then checkout the `development` branch
    #   git = Git.clone('https://github.com/ruby-git/ruby-git.git', branch: 'development')
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @param repository_url [URI, Pathname] The (possibly remote) repository url to clone
    #   from. See [GIT URLS](https://git-scm.com/docs/git-clone#_git_urls_a_id_urls_a)
    #   for more information.
    # @param directory [Pathname, nil] The directory to clone into
    #
    #   If `directory` is a relative directory it is relative to the `path` option if
    #   given. If `path` is not given, `directory` is relative to the current working
    #   directory.
    #
    #   If `nil`, `directory` will be set to the basename of the last component of
    #   the path from the `repository_url`. For example, for the URL:
    #   `https://github.com/org/repo.git`, `directory` will be set to `repo`.
    #
    #   If the last component of the path is `.git`, the next-to-last component of
    #   the path is used. For example, for the URL `/Users/me/foo/.git`, `directory`
    #   will be set to `foo`.
    # @param options [Hash] The options for this command (see list of valid
    #   options below)
    # @return [Git::Base] an object that can execute git commands in the context
    #   of the cloned local working copy or cloned repository.
    # @see https://git-scm.com/docs/git-clone git clone
    # @see https://git-scm.com/docs/git-clone#_git_urls_a_id_urls_a GIT URLs
    def clone(repository_url, directory = T.unsafe(nil), options = T.unsafe(nil)); end

    def config; end

    # @yield [Base.config]
    def configure; end

    # Export the current HEAD (or a branch, if <tt>options[:branch]</tt>
    # is specified) into the +name+ directory, then remove all traces of git from the
    # directory.
    #
    # See +clone+ for options.  Does not obey the <tt>:remote</tt> option,
    # since the .git info will be deleted anyway; always uses the default
    # remote, 'origin.'
    def export(repository, name, options = T.unsafe(nil)); end

    # Same as g.config, but forces it to be at the global level
    #
    # g.config('user.name', 'Scott Chacon') # sets value
    # g.config('user.email', 'email@email.com')  # sets value
    # g.config('user.name')  # returns 'Scott Chacon'
    # g.config # returns whole config hash
    def global_config(name = T.unsafe(nil), value = T.unsafe(nil)); end

    # Create an empty Git repository or reinitialize an existing Git repository
    #
    # @example Initialize a repository in some other directory
    #   git = Git.init '~/code/ruby-git'
    # @example Initialize a bare repository
    #   git = Git.init '~/code/ruby-git.git', bare: true
    # @example Initialize a repository in the current directory
    #   git = Git.init
    # @example Initialize a repository in a non-default location (outside of the working copy)
    #   git = Git.init '~/code/ruby-git', repository: '~/code/ruby-git.git'
    # @option options
    # @option options
    # @option options
    # @option options
    # @param directory [Pathname] If the `:bare` option is NOT given or is not
    #   `true`, the repository will be created in `"#{directory}/.git"`.
    #   Otherwise, the repository is created in `"#{directory}"`.
    #
    #   All directories along the path to `directory` are created if they do not exist.
    #
    #   A relative path is referenced from the current working directory of the process
    #   and converted to an absolute path using
    #   [File.expand_path](https://www.rubydoc.info/stdlib/core/File.expand_path).
    # @param options [Hash] The options for this command (see list of valid
    #   options below)
    # @return [Git::Base] an object that can execute git commands in the context
    #   of the newly initialized repository
    # @see https://git-scm.com/docs/git-init git init
    def init(directory = T.unsafe(nil), options = T.unsafe(nil)); end

    # returns a Hash containing information about the references
    # of the target repository
    #
    # options
    #   :refs
    #
    # @param location [String|NilClass] the target repository location or nil for '.'
    # @return [{String=>Hash}] the available references of the target repo.
    def ls_remote(location = T.unsafe(nil), options = T.unsafe(nil)); end

    # Open a an existing Git working directory
    #
    # Git.open will most likely be the most common way to create
    # a git reference, referring to an existing working directory.
    #
    # If not provided in the options, the library will assume
    # the repository and index are in the default places (`.git/`, `.git/index`).
    #
    # @example Open a Git working directory in some other directory
    #   git = Git.open('~/Projects/ruby-git')
    # @example Open the Git working directory in the current directory
    #   git = Git.open
    # @example Use a logger to see what is going on
    #   logger = Logger.new(STDOUT)
    #   git = Git.open('~/Projects/ruby-git', log: logger)
    # @example Open a working copy whose repository is in a non-standard directory
    #   git = Git.open('~/Projects/ruby-git', repository: '~/Project/ruby-git.git')
    # @option options
    # @option options
    # @option options
    # @param working_dir [Pathname] the path to the working directory to use
    #   for git commands.
    #
    #   A relative path is referenced from the current working directory of the process
    #   and converted to an absolute path using
    #   [File.expand_path](https://www.rubydoc.info/stdlib/core/File.expand_path).
    # @param options [Hash] The options for this command (see list of valid
    #   options below)
    # @return [Git::Base] an object that can execute git commands in the context
    #   of the opened working copy
    def open(working_dir, options = T.unsafe(nil)); end
  end
end

class Git::Author
  # @return [Author] a new instance of Author
  def initialize(author_string); end

  # Returns the value of attribute date.
  def date; end

  # Sets the attribute date
  #
  # @param value the value to set the attribute date to.
  def date=(_arg0); end

  # Returns the value of attribute email.
  def email; end

  # Sets the attribute email
  #
  # @param value the value to set the attribute email to.
  def email=(_arg0); end

  # Returns the value of attribute name.
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  def name=(_arg0); end
end

# Git::Base is the main public interface for interacting with Git commands.
#
# Instead of creating a Git::Base directly, obtain a Git::Base instance by
# calling one of the follow {Git} class methods: {Git.open}, {Git.init},
# {Git.clone}, or {Git.bare}.
class Git::Base
  include ::Git::Base::Factory

  # Create an object that executes Git commands in the context of a working
  # copy or a bare repository.
  #
  # @option options
  # @option options
  # @option options
  # @option options
  # @param options [Hash] The options for this command (see list of valid
  #   options below)
  # @return [Git::Base] an object that can execute git commands in the context
  #   of the opened working copy or bare repository
  def initialize(options = T.unsafe(nil)); end

  # updates the repository index using the working directory content
  #
  # options:
  #   :all => true
  #
  # @example
  #   git.add
  #   git.add('path/to/file')
  #   git.add(['path/to/file1','path/to/file2'])
  #   git.add(:all => true)
  # @option options
  # @param paths [String, Array] files paths to be added (optional, default='.')
  # @param options [Hash]
  def add(paths = T.unsafe(nil), **options); end

  # adds a new remote to this repository
  # url can be a git url or a Git::Base object if it's a local reference
  #
  #  @git.add_remote('scotts_git', 'git://repo.or.cz/rubygit.git')
  #  @git.fetch('scotts_git')
  #  @git.merge('scotts_git/master')
  #
  # Options:
  #   :fetch => true
  #   :track => <branch_name>
  def add_remote(name, url, opts = T.unsafe(nil)); end

  # Creates a new git tag (Git::Tag)
  #
  # @example
  #   repo.add_tag('tag_name', object_reference)
  #   repo.add_tag('tag_name', object_reference, {:options => 'here'})
  #   repo.add_tag('tag_name', {:options => 'here'})
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @param name [String] The name of the tag to add
  # @param options [Hash] Opstions to pass to `git tag`.
  #   See [git-tag](https://git-scm.com/docs/git-tag) for more details.
  def add_tag(name, *options); end

  def apply(file); end
  def apply_mail(file); end

  # creates an archive file of the given tree-ish
  def archive(treeish, file = T.unsafe(nil), opts = T.unsafe(nil)); end

  def cat_file(objectish); end

  # changes current working directory for a block
  # to the git working directory
  #
  # example
  #  @git.chdir do
  #    # write files
  #    @git.add
  #    @git.commit('message')
  #  end
  def chdir; end

  # checks out a branch as the new git working directory
  def checkout(branch = T.unsafe(nil), opts = T.unsafe(nil)); end

  # checks out an old version of a file
  def checkout_file(version, file); end

  def checkout_index(opts = T.unsafe(nil)); end

  # cleans the working directory
  #
  # options:
  #  :force
  #  :d
  #  :ff
  def clean(opts = T.unsafe(nil)); end

  # commits all pending changes in the index file to the git repository
  #
  # options:
  #   :all
  #   :allow_empty
  #   :amend
  #   :author
  def commit(message, opts = T.unsafe(nil)); end

  # commits all pending changes in the index file to the git repository,
  # but automatically adds all modified files without having to explicitly
  # calling @git.add() on them.
  def commit_all(message, opts = T.unsafe(nil)); end

  # g.config('user.name', 'Scott Chacon') # sets value
  # g.config('user.email', 'email@email.com')  # sets value
  # g.config('user.email', 'email@email.com', file: 'path/to/custom/config)  # sets value in file
  # g.config('user.name')  # returns 'Scott Chacon'
  # g.config # returns whole config hash
  def config(name = T.unsafe(nil), value = T.unsafe(nil), options = T.unsafe(nil)); end

  # returns the name of the branch the working directory is currently on
  def current_branch; end

  # deletes a tag
  def delete_tag(name); end

  # returns the most recent tag that is reachable from a commit
  #
  # options:
  #  :all
  #  :tags
  #  :contains
  #  :debug
  #  :exact_match
  #  :dirty
  #  :abbrev
  #  :candidates
  #  :long
  #  :always
  #  :match
  def describe(committish = T.unsafe(nil), opts = T.unsafe(nil)); end

  # returns a reference to the working directory
  #  @git.dir.path
  #  @git.dir.writeable?
  def dir; end

  # iterates over the files which are unmerged
  def each_conflict(&block); end

  # fetches changes from a remote branch - this does not modify the working directory,
  # it just gets the changes from the remote if there are any
  def fetch(remote = T.unsafe(nil), opts = T.unsafe(nil)); end

  def gc; end

  # Run a grep for 'string' on the HEAD of the git repository
  #
  # @example Limit grep's scope by calling grep() from a specific object:
  #   git.object("v2.3").grep('TODO')
  # @example Using grep results:
  #   git.grep("TODO").each do |sha, arr|
  #   puts "in blob #{sha}:"
  #   arr.each do |line_no, match_string|
  #   puts "\t line #{line_no}: '#{match_string}'"
  #   end
  #   end
  # @return [Hash<String, Array>] a hash of arrays
  #   ```Ruby
  #   {
  #   'tree-ish1' => [[line_no1, match_string1], ...],
  #   'tree-ish2' => [[line_no1, match_string1], ...],
  #   ...
  #   }
  #   ```
  def grep(string, path_limiter = T.unsafe(nil), opts = T.unsafe(nil)); end

  # returns reference to the git index file
  def index; end

  # returns +true+ if the branch exists
  #
  # @return [Boolean]
  def is_branch?(branch); end

  # returns +true+ if the branch exists locally
  #
  # @return [Boolean]
  def is_local_branch?(branch); end

  # returns +true+ if the branch exists remotely
  #
  # @return [Boolean]
  def is_remote_branch?(branch); end

  # this is a convenience method for accessing the class that wraps all the
  # actual 'git' forked system calls.  At some point I hope to replace the Git::Lib
  # class with one that uses native methods or libgit C bindings
  def lib; end

  def ls_files(location = T.unsafe(nil)); end
  def ls_tree(objectish); end

  # merges one or more branches into the current working branch
  #
  # you can specify more than one branch to merge by passing an array of branches
  def merge(branch, message = T.unsafe(nil), opts = T.unsafe(nil)); end

  # Use git-merge-base https://git-scm.com/docs/git-merge-base to
  # find as good common ancestors as possible for a merge
  def merge_base(commit1, commit2, *other_commits); end

  # pulls the given branch from the given remote into the current branch
  #
  #  @git.pull                          # pulls from origin/master
  #  @git.pull('upstream')              # pulls from upstream/master
  #  @git.pull('upstream', 'develope')  # pulls from upstream/develop
  def pull(remote = T.unsafe(nil), branch = T.unsafe(nil)); end

  # pushes changes to a remote repository - easiest if this is a cloned repository,
  # otherwise you may have to run something like this first to setup the push parameters:
  #
  #  @git.config('remote.remote-name.push', 'refs/heads/master:refs/heads/master')
  def push(remote = T.unsafe(nil), branch = T.unsafe(nil), opts = T.unsafe(nil)); end

  def read_tree(treeish, opts = T.unsafe(nil)); end

  # returns an array of Git:Remote objects
  def remotes; end

  # removes file(s) from the git repository
  def remove(path = T.unsafe(nil), opts = T.unsafe(nil)); end

  # removes a remote from this repository
  #
  # @git.remove_remote('scott_git')
  def remove_remote(name); end

  # repacks the repository
  def repack; end

  # returns reference to the git repository directory
  #  @git.dir.path
  def repo; end

  # returns the repository size in bytes
  def repo_size; end

  # resets the working directory to the provided commitish
  def reset(commitish = T.unsafe(nil), opts = T.unsafe(nil)); end

  # resets the working directory to the commitish with '--hard'
  def reset_hard(commitish = T.unsafe(nil), opts = T.unsafe(nil)); end

  # reverts the working directory to the provided commitish.
  # Accepts a range, such as comittish..HEAD
  #
  # options:
  #   :no_edit
  def revert(commitish = T.unsafe(nil), opts = T.unsafe(nil)); end

  # runs git rev-parse to convert the objectish to a full sha
  #
  # @example
  #   git.revparse("HEAD^^")
  #   git.revparse('v2.4^{tree}')
  #   git.revparse('v2.4:/doc/index.html')
  def revparse(objectish); end

  def set_index(index_file, check = T.unsafe(nil)); end

  # sets the url for a remote
  # url can be a git url or a Git::Base object if it's a local reference
  #
  #  @git.set_remote_url('scotts_git', 'git://repo.or.cz/rubygit.git')
  def set_remote_url(name, url); end

  def set_working(work_dir, check = T.unsafe(nil)); end

  # Shows objects
  #
  # @param objectish [String|NilClass] the target object reference (nil == HEAD)
  # @param path [String|NilClass] the path of the file to be shown
  # @return [String] the object information
  def show(objectish = T.unsafe(nil), path = T.unsafe(nil)); end

  # returns an array of all Git::Tag objects for this repository
  def tags; end

  def update_ref(branch, commit); end

  # LOWER LEVEL INDEX OPERATIONS ##
  def with_index(new_index); end

  def with_temp_index(&blk); end
  def with_temp_working(&blk); end

  # :yields: the Git::WorkingDirectory
  def with_working(work_dir); end

  def write_and_commit_tree(opts = T.unsafe(nil)); end
  def write_tree; end

  class << self
    # Open a bare repository
    #
    # Opens a bare repository located in the `git_dir` directory.
    # Since there is no working copy, you can not checkout or commit
    # but you can do most read operations.
    #
    # @example Open a bare repository and retrieve the first commit SHA
    #   repository = Git.bare('ruby-git.git')
    #   puts repository.log[0].sha #=> "64c6fa011d3287bab9158049c85f3e85718854a0"
    # @option options
    # @param git_dir [Pathname] The path to the bare repository directory
    #   containing an initialized Git repository. If a relative path is given, it
    #   is converted to an absolute path using
    #   [File.expand_path](https://www.rubydoc.info/stdlib/core/File.expand_path).
    # @param options [Hash] The options for this command (see list of valid
    #   options below)
    # @return [Git::Base] an object that can execute git commands in the context
    #   of the bare repository.
    # @see https://git-scm.com/docs/gitglossary#Documentation/gitglossary.txt-aiddefbarerepositoryabarerepository What is a bare repository?
    def bare(git_dir, options = T.unsafe(nil)); end

    # Clone a repository into an empty or newly created directory
    #
    # @example Clone into a different directory `my-ruby-git`
    #   git = Git.clone('https://github.com/ruby-git/ruby-git.git', 'my-ruby-git')
    #   # or:
    #   git = Git.clone('https://github.com/ruby-git/ruby-git.git', path: 'my-ruby-git')
    # @example Clone into the default directory `ruby-git`
    #   git = Git.clone('https://github.com/ruby-git/ruby-git.git')
    # @example Create a bare repository in the directory `ruby-git.git`
    #   git = Git.clone('https://github.com/ruby-git/ruby-git.git', bare: true)
    # @example Clone and then checkout the `development` branch
    #   git = Git.clone('https://github.com/ruby-git/ruby-git.git', branch: 'development')
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @param repository_url [URI, Pathname] The (possibly remote) repository url to clone
    #   from. See [GIT URLS](https://git-scm.com/docs/git-clone#_git_urls_a_id_urls_a)
    #   for more information.
    # @param directory [Pathname, nil] The directory to clone into
    #
    #   If `directory` is a relative directory it is relative to the `path` option if
    #   given. If `path` is not given, `directory` is relative to the current working
    #   directory.
    #
    #   If `nil`, `directory` will be set to the basename of the last component of
    #   the path from the `repository_url`. For example, for the URL:
    #   `https://github.com/org/repo.git`, `directory` will be set to `repo`.
    #
    #   If the last component of the path is `.git`, the next-to-last component of
    #   the path is used. For example, for the URL `/Users/me/foo/.git`, `directory`
    #   will be set to `foo`.
    # @param options [Hash] The options for this command (see list of valid
    #   options below)
    # @return [Git::Base] an object that can execute git commands in the context
    #   of the cloned local working copy or cloned repository.
    # @see https://git-scm.com/docs/git-clone git clone
    # @see https://git-scm.com/docs/git-clone#_git_urls_a_id_urls_a GIT URLs
    def clone(repository_url, directory, options = T.unsafe(nil)); end

    # Returns (and initialize if needed) a Git::Config instance
    #
    # @return [Git::Config] the current config instance.
    def config; end

    # Create an empty Git repository or reinitialize an existing Git repository
    #
    # @example Initialize a repository in some other directory
    #   git = Git.init '~/code/ruby-git'
    # @example Initialize a bare repository
    #   git = Git.init '~/code/ruby-git.git', bare: true
    # @example Initialize a repository in the current directory
    #   git = Git.init
    # @example Initialize a repository in a non-default location (outside of the working copy)
    #   git = Git.init '~/code/ruby-git', repository: '~/code/ruby-git.git'
    # @option options
    # @option options
    # @option options
    # @option options
    # @param directory [Pathname] If the `:bare` option is NOT given or is not
    #   `true`, the repository will be created in `"#{directory}/.git"`.
    #   Otherwise, the repository is created in `"#{directory}"`.
    #
    #   All directories along the path to `directory` are created if they do not exist.
    #
    #   A relative path is referenced from the current working directory of the process
    #   and converted to an absolute path using
    #   [File.expand_path](https://www.rubydoc.info/stdlib/core/File.expand_path).
    # @param options [Hash] The options for this command (see list of valid
    #   options below)
    # @return [Git::Base] an object that can execute git commands in the context
    #   of the newly initialized repository
    # @see https://git-scm.com/docs/git-init git init
    def init(directory = T.unsafe(nil), options = T.unsafe(nil)); end

    # Open a an existing Git working directory
    #
    # Git.open will most likely be the most common way to create
    # a git reference, referring to an existing working directory.
    #
    # If not provided in the options, the library will assume
    # the repository and index are in the default places (`.git/`, `.git/index`).
    #
    # @example Open a Git working directory in some other directory
    #   git = Git.open('~/Projects/ruby-git')
    # @example Open the Git working directory in the current directory
    #   git = Git.open
    # @example Use a logger to see what is going on
    #   logger = Logger.new(STDOUT)
    #   git = Git.open('~/Projects/ruby-git', log: logger)
    # @example Open a working copy whose repository is in a non-standard directory
    #   git = Git.open('~/Projects/ruby-git', repository: '~/Project/ruby-git.git')
    # @option options
    # @option options
    # @option options
    # @param working_dir [Pathname] the path to the working directory to use
    #   for git commands.
    #
    #   A relative path is referenced from the current working directory of the process
    #   and converted to an absolute path using
    #   [File.expand_path](https://www.rubydoc.info/stdlib/core/File.expand_path).
    # @param options [Hash] The options for this command (see list of valid
    #   options below)
    # @return [Git::Base] an object that can execute git commands in the context
    #   of the opened working copy
    def open(working_dir, options = T.unsafe(nil)); end

    private

    # Normalize options[:index]
    #
    # If options[:index] is a relative directory, convert it to an absolute
    # directory relative to the repository directory
    def normalize_index(options); end

    # Normalize options before they are sent to Git::Base.new
    #
    # Updates the options parameter by setting appropriate values for the following keys:
    #   * options[:working_directory]
    #   * options[:repository]
    #   * options[:index]
    #
    # All three values will be set to absolute paths. An exception is that
    # :working_directory will be set to nil if bare is true.
    def normalize_paths(options, default_working_directory: T.unsafe(nil), default_repository: T.unsafe(nil), bare: T.unsafe(nil)); end

    # Normalize options[:repository]
    #
    # If working with a bare repository, set to the first non-nil value out of:
    #   1. `options[:repository]`
    #   2. the `default` parameter
    #   3. the current working directory
    #
    # Otherwise, set to the first non-nil value of:
    #   1. `options[:repository]`
    #   2. `.git`
    #
    # Next, if options[:repository] refers to a *file* and not a *directory*, set
    # options[:repository] to the contents of that file.  This is the case when
    # working with a submodule or a secondary working tree (created with git worktree
    # add). In these cases the repository is actually contained/nested within the
    # parent's repository directory.
    #
    # Finally, if options[:repository] is a relative path, convert it to an absolute
    # path relative to:
    #   1. the current directory if working with a bare repository or
    #   2. the working directory if NOT working with a bare repository
    def normalize_repository(options, default:, bare: T.unsafe(nil)); end

    # Normalize options[:working_directory]
    #
    # If working with a bare repository, set to `nil`.
    # Otherwise, set to the first non-nil value of:
    #   1. `options[:working_directory]`,
    #   2. the `default` parameter, or
    #   3. the current working directory
    #
    # Finally, if options[:working_directory] is a relative path, convert it to an absoluite
    # path relative to the current directory.
    def normalize_working_directory(options, default:, bare: T.unsafe(nil)); end
  end
end

module Git::Base::Factory
  # @return [Git::Branch] an object for branch_name
  def branch(branch_name = T.unsafe(nil)); end

  # @return [Git::Branches] a collection of all the branches in the repository.
  #   Each branch is represented as a {Git::Branch}.
  def branches; end

  # @return [Git::Object::Commit] a commit object
  def commit_tree(tree = T.unsafe(nil), opts = T.unsafe(nil)); end

  # @return [Git::Diff] a Git::Diff object
  def diff(objectish = T.unsafe(nil), obj2 = T.unsafe(nil)); end

  # @return [Git::Object] a Git object
  def gblob(objectish); end

  # @return [Git::Object] a Git object
  def gcommit(objectish); end

  # @return [Git::Object] a Git object
  def gtree(objectish); end

  # @return [Git::Log] a log with the specified number of commits
  def log(count = T.unsafe(nil)); end

  # Find as good common ancestors as possible for a merge
  # example: g.merge_base('master', 'some_branch', 'some_sha', octopus: true)
  #
  # @return [Array<Git::Object::Commit>] a collection of common ancestors
  def merge_base(*args); end

  # returns a Git::Object of the appropriate type
  # you can also call @git.gtree('tree'), but that's
  # just for readability.  If you call @git.gtree('HEAD') it will
  # still return a Git::Object::Commit object.
  #
  # object calls a factory method that will run a rev-parse
  # on the objectish and determine the type of the object and return
  # an appropriate object for that type
  #
  # @return [Git::Object] an instance of the appropriate type of Git::Object
  def object(objectish); end

  # @return [Git::Remote] a remote of the specified name
  def remote(remote_name = T.unsafe(nil)); end

  # @return [Git::Status] a status object
  def status; end

  # @return [Git::Object::Tag] a tag object
  def tag(tag_name); end

  # returns a Git::Worktree object for dir, commitish
  def worktree(dir, commitish = T.unsafe(nil)); end

  # returns a Git::worktrees object of all the Git::Worktrees
  # objects for this repo
  def worktrees; end
end

class Git::Branch < ::Git::Path
  # @return [Branch] a new instance of Branch
  def initialize(base, name); end

  def archive(file, opts = T.unsafe(nil)); end
  def checkout; end

  # @return [Boolean]
  def contains?(commit); end

  def create; end
  def current; end
  def delete; end

  # Returns the value of attribute full.
  def full; end

  # Sets the attribute full
  #
  # @param value the value to set the attribute full to.
  def full=(_arg0); end

  def gcommit; end

  # g.branch('new_branch').in_branch do
  #   # create new file
  #   # do other stuff
  #   return true # auto commits and switches back
  # end
  def in_branch(message = T.unsafe(nil)); end

  def merge(branch = T.unsafe(nil), message = T.unsafe(nil)); end

  # Returns the value of attribute name.
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  def name=(_arg0); end

  # Returns the value of attribute remote.
  def remote; end

  # Sets the attribute remote
  #
  # @param value the value to set the attribute remote to.
  def remote=(_arg0); end

  def stashes; end
  def to_a; end
  def to_s; end
  def update_ref(commit); end

  private

  def check_if_create; end
  def determine_current; end

  # Given a full branch name return an Array containing the remote and branch names.
  #
  # Removes 'remotes' from the beggining of the name (if present).
  # Takes the second part (splittign by '/') as the remote name.
  # Takes the rest as the repo name (can also hold one or more '/').
  #
  # Example:
  #   parse_name('master') #=> [nil, 'master']
  #   parse_name('origin/master') #=> ['origin', 'master']
  #   parse_name('remotes/origin/master') #=> ['origin', 'master']
  #   parse_name('origin/master/v2') #=> ['origin', 'master/v2']
  #
  # param [String] name branch full name.
  # return [<Git::Remote,NilClass,String>] an Array containing the remote and branch names.
  def parse_name(name); end
end

# object that holds all the available branches
class Git::Branches
  include ::Enumerable

  # @return [Branches] a new instance of Branches
  def initialize(base); end

  # Returns the target branch
  #
  # Example:
  #   Given (git branch -a):
  #    master
  #    remotes/working/master
  #
  #   g.branches['master'].full #=> 'master'
  #   g.branches['working/master'].full => 'remotes/working/master'
  #   g.branches['remotes/working/master'].full => 'remotes/working/master'
  #
  # @param branch_name [#to_s] the target branch name.
  # @return [Git::Branch] the target branch.
  def [](branch_name); end

  def each(&block); end
  def local; end
  def remote; end

  # array like methods
  def size; end

  def to_s; end
end

class Git::Config
  # @return [Config] a new instance of Config
  def initialize; end

  def binary_path; end

  # Sets the attribute binary_path
  #
  # @param value the value to set the attribute binary_path to.
  def binary_path=(_arg0); end

  def git_ssh; end

  # Sets the attribute git_ssh
  #
  # @param value the value to set the attribute git_ssh to.
  def git_ssh=(_arg0); end
end

# object that holds the last X commits on given branch
class Git::Diff
  include ::Enumerable

  # @return [Diff] a new instance of Diff
  def initialize(base, from = T.unsafe(nil), to = T.unsafe(nil)); end

  # enumerable methods
  def [](key); end

  def deletions; end

  # :yields: each Git::DiffFile in turn
  def each(&block); end

  # Returns the value of attribute from.
  def from; end

  def insertions; end
  def lines; end
  def name_status; end

  # if file is provided and is writable, it will write the patch into the file
  def patch(file = T.unsafe(nil)); end

  def path(path); end
  def size; end
  def stats; end

  # Returns the value of attribute to.
  def to; end

  # if file is provided and is writable, it will write the patch into the file
  def to_s(file = T.unsafe(nil)); end

  private

  def cache_full; end
  def cache_name_status; end
  def cache_stats; end
  def process_full; end

  # break up @diff_full
  def process_full_diff; end
end

class Git::Diff::DiffFile
  # @return [DiffFile] a new instance of DiffFile
  def initialize(base, hash); end

  # @return [Boolean]
  def binary?; end

  def blob(type = T.unsafe(nil)); end

  # Returns the value of attribute dst.
  def dst; end

  # Sets the attribute dst
  #
  # @param value the value to set the attribute dst to.
  def dst=(_arg0); end

  # Returns the value of attribute mode.
  def mode; end

  # Sets the attribute mode
  #
  # @param value the value to set the attribute mode to.
  def mode=(_arg0); end

  # Returns the value of attribute patch.
  def patch; end

  # Sets the attribute patch
  #
  # @param value the value to set the attribute patch to.
  def patch=(_arg0); end

  # Returns the value of attribute path.
  def path; end

  # Sets the attribute path
  #
  # @param value the value to set the attribute path to.
  def path=(_arg0); end

  # Returns the value of attribute src.
  def src; end

  # Sets the attribute src
  #
  # @param value the value to set the attribute src to.
  def src=(_arg0); end

  # Returns the value of attribute type.
  def type; end

  # Sets the attribute type
  #
  # @param value the value to set the attribute type to.
  def type=(_arg0); end
end

Git::Diff::DiffFile::NIL_BLOB_REGEXP = T.let(T.unsafe(nil), Regexp)

# Method that can be used to detect and normalize string encoding
module Git::EncodingUtils
  class << self
    def best_guess_encoding; end
    def default_encoding; end
    def detected_encoding(str); end
    def encoding_options; end
    def normalize_encoding(str); end
  end
end

# Represents an escaped Git path string
#
# Git commands that output paths (e.g. ls-files, diff), will escape usual
# characters in the path with backslashes in the same way C escapes control
# characters (e.g. \t for TAB, \n for LF, \\ for backslash) or bytes with values
# larger than 0x80 (e.g. octal \302\265 for "micro" in UTF-8).
#
# @example
#   Git::GitPath.new('\302\265').unescape # => "Âµ"
class Git::EscapedPath
  # @return [EscapedPath] a new instance of EscapedPath
  def initialize(path); end

  # Returns the value of attribute path.
  def path; end

  # Convert an escaped path to an unescaped path
  def unescape; end

  private

  def escaped_path_to_bytes(path); end
  def extract_escape(path, index); end
  def extract_octal(path, index); end
  def extract_single_char(path, index); end
  def next_byte(path, index); end
end

Git::EscapedPath::UNESCAPES = T.let(T.unsafe(nil), Hash)

# The URI for git's alternative scp-like syntax
#
# This class is necessary to ensure that #to_s returns the same string
# that was passed to the initializer.
#
# @api public
class Git::GitAltURI < ::Addressable::URI
  # Create a new GitAltURI object
  #
  # @api public
  # @example
  #   uri = Git::GitAltURI.new(user: 'james', host: 'github.com', path: 'james/ruby-git')
  #   uri.to_s #=> 'james@github.com/james/ruby-git'
  # @param user [String, nil] the user from the URL or nil
  # @param host [String] the host from the URL
  # @param path [String] the path from the URL
  # @return [GitAltURI] a new instance of GitAltURI
  def initialize(user:, host:, path:); end

  # Convert the URI to a String
  #
  # Addressible::URI forces path to be absolute by prepending a '/' to the
  # path. This method removes the '/' when converting back to a string
  # since that is what is expected by git. The following is a valid git URL:
  #
  #  `james@github.com:ruby-git/ruby-git.git`
  #
  # and the following (with the initial '/'' in the path) is NOT a valid git URL:
  #
  #  `james@github.com:/ruby-git/ruby-git.git`
  #
  # @api public
  # @example
  #   uri = Git::GitAltURI.new(user: 'james', host: 'github.com', path: 'james/ruby-git')
  #   uri.path #=> '/james/ruby-git'
  #   uri.to_s #=> 'james@github.com:james/ruby-git'
  # @return [String] the URI as a String
  def to_s; end
end

class Git::GitExecuteError < ::StandardError; end
class Git::GitTagNameDoesNotExist < ::StandardError; end
class Git::Index < ::Git::Path; end

class Git::Lib
  # Create a new Git::Lib object
  #
  # @option base
  # @option base
  # @option base
  # @param base [Git::Base, Hash] An object that passes in values for
  #   @git_work_dir, @git_dir, and @git_index_file
  # @param logger [Logger]
  # @return [Lib] a new instance of Lib
  def initialize(base = T.unsafe(nil), logger = T.unsafe(nil)); end

  # updates the repository index using the working directory content
  #
  #    lib.add('path/to/file')
  #    lib.add(['path/to/file1','path/to/file2'])
  #    lib.add(:all => true)
  #
  # options:
  #   :all => true
  #   :force => true
  #
  # @param paths [String, Array] files paths to be added to the repository
  # @param options [Hash]
  def add(paths = T.unsafe(nil), options = T.unsafe(nil)); end

  def apply(patch_file); end
  def apply_mail(patch_file); end

  # creates an archive file
  #
  # options
  #  :format  (zip, tar)
  #  :prefix
  #  :remote
  #  :path
  def archive(sha, file = T.unsafe(nil), opts = T.unsafe(nil)); end

  def branch_contains(commit, branch_name = T.unsafe(nil)); end
  def branch_current; end
  def branch_delete(branch); end
  def branch_new(branch); end
  def branches_all; end
  def change_head_branch(branch_name); end
  def checkout(branch, opts = T.unsafe(nil)); end
  def checkout_file(version, file); end
  def checkout_index(opts = T.unsafe(nil)); end
  def clean(opts = T.unsafe(nil)); end

  # tries to clone the given repo
  #
  # accepts options:
  #  :bare::      no working directory
  #  :branch::    name of branch to track (rather than 'master')
  #  :depth::     the number of commits back to pull
  #  :origin::    name of remote (same as remote)
  #  :path::      directory where the repo will be cloned
  #  :remote::    name of remote (rather than 'origin')
  #  :recursive:: after the clone is created, initialize all submodules within, using their default settings.
  #
  # TODO - make this work with SSH password or auth_key
  #
  # @return [Hash] the options to pass to {Git::Base.new}
  def clone(repository_url, directory, opts = T.unsafe(nil)); end

  # Takes the commit message with the options and executes the commit command
  #
  # accepts options:
  #  :amend
  #  :all
  #  :allow_empty
  #  :author
  #  :date
  #  :no_verify
  #  :allow_empty_message
  #  :gpg_sign (accepts true or a gpg key ID as a String)
  #  :no_gpg_sign (conflicts with :gpg_sign)
  #
  # @param message [String] the commit message to be used
  # @param opts [Hash] the commit options to be used
  def commit(message, opts = T.unsafe(nil)); end

  # returns useful array of raw commit object data
  def commit_data(sha); end

  def commit_tree(tree, opts = T.unsafe(nil)); end
  def config_get(name); end
  def config_list; end
  def config_remote(name); end

  # WRITE COMMANDS ##
  def config_set(name, value, options = T.unsafe(nil)); end

  # :yields: file, your, their
  def conflicts; end

  # returns the current version of git, as an Array of Fixnums.
  def current_command_version; end

  # Returns most recent tag that is reachable from a commit
  #
  # accepts options:
  #  :all
  #  :tags
  #  :contains
  #  :debug
  #  :exact_match
  #  :dirty
  #  :abbrev
  #  :candidates
  #  :long
  #  :always
  #  :math
  #
  #  @param [String|NilClass] committish target commit sha or object name
  #  @param [{Symbol=>Object}] opts the given options
  #  @return [String] the tag name
  def describe(committish = T.unsafe(nil), opts = T.unsafe(nil)); end

  # compares the index and the working directory
  def diff_files; end

  def diff_full(obj1 = T.unsafe(nil), obj2 = T.unsafe(nil), opts = T.unsafe(nil)); end

  # compares the index and the repository
  def diff_index(treeish); end

  def diff_name_status(reference1 = T.unsafe(nil), reference2 = T.unsafe(nil), opts = T.unsafe(nil)); end
  def diff_stats(obj1 = T.unsafe(nil), obj2 = T.unsafe(nil), opts = T.unsafe(nil)); end
  def fetch(remote, opts); end
  def full_log_commits(opts = T.unsafe(nil)); end
  def full_tree(sha); end
  def gc; end

  # The path to the Git repository directory.  The default is
  # `"#{git_work_dir}/.git"`.
  #
  # @return [Pathname] the Git repository directory.
  # @see [Git repository](https://git-scm.com/docs/gitglossary#Documentation/gitglossary.txt-aiddefrepositoryarepository)
  def git_dir; end

  # The Git index file used to stage changes (using `git add`) before they
  # are committed.
  #
  # @return [Pathname] the Git index file
  # @see [Git index file](https://git-scm.com/docs/gitglossary#Documentation/gitglossary.txt-aiddefindexaindex)
  def git_index_file; end

  # The path to the Git working copy.  The default is '"./.git"'.
  #
  # @return [Pathname] the path to the Git working copy.
  # @see [Git working tree](https://git-scm.com/docs/gitglossary#Documentation/gitglossary.txt-aiddefworkingtreeaworkingtree)
  def git_work_dir; end

  def global_config_get(name); end
  def global_config_list; end
  def global_config_set(name, value); end

  # returns hash
  # [tree-ish] = [[line_no, match], [line_no, match2]]
  # [tree-ish] = [[line_no, match], [line_no, match2]]
  def grep(string, opts = T.unsafe(nil)); end

  def ignored_files; end

  # creates or reinitializes the repository
  #
  # options:
  #   :bare
  #   :working_directory
  #   :initial_branch
  def init(opts = T.unsafe(nil)); end

  def list_files(ref_dir); end
  def log_commits(opts = T.unsafe(nil)); end
  def ls_files(location = T.unsafe(nil)); end
  def ls_remote(location = T.unsafe(nil), opts = T.unsafe(nil)); end
  def ls_tree(sha); end

  # @return [Boolean]
  def meets_required_version?; end

  def merge(branch, message = T.unsafe(nil), opts = T.unsafe(nil)); end
  def merge_base(*args); end
  def mv(file1, file2); end
  def namerev(string); end
  def object_contents(sha, &block); end
  def object_size(sha); end
  def object_type(sha); end
  def parse_config(file); end
  def parse_config_list(lines); end
  def process_commit_data(data, sha = T.unsafe(nil), indent = T.unsafe(nil)); end
  def process_commit_log_data(data); end
  def process_tag_data(data, name, indent = T.unsafe(nil)); end
  def pull(remote = T.unsafe(nil), branch = T.unsafe(nil)); end
  def push(remote, branch = T.unsafe(nil), opts = T.unsafe(nil)); end

  # reads a tree into the current index file
  def read_tree(treeish, opts = T.unsafe(nil)); end

  def remote_add(name, url, opts = T.unsafe(nil)); end
  def remote_remove(name); end
  def remote_set_url(name, url); end
  def remotes; end
  def remove(path = T.unsafe(nil), opts = T.unsafe(nil)); end
  def repack; end
  def required_command_version; end
  def reset(commit, opts = T.unsafe(nil)); end
  def return_base_opts_from_clone(clone_dir, opts); end
  def revert(commitish, opts = T.unsafe(nil)); end
  def revparse(string); end

  # Shows objects
  #
  # @param objectish [String|NilClass] the target object reference (nil == HEAD)
  # @param path [String|NilClass] the path of the file to be shown
  # @return [String] the object information
  def show(objectish = T.unsafe(nil), path = T.unsafe(nil)); end

  def stash_apply(id = T.unsafe(nil)); end
  def stash_clear; end
  def stash_list; end
  def stash_save(message); end
  def stashes_all; end
  def tag(name, *opts); end
  def tag_data(name); end
  def tag_sha(tag_name); end
  def tags; end
  def tree_depth(sha); end
  def unmerged; end
  def update_ref(branch, commit); end
  def worktree_add(dir, commitish = T.unsafe(nil)); end
  def worktree_prune; end
  def worktree_remove(dir); end
  def worktrees_all; end
  def write_tree; end

  private

  # @raise [Git::GitExecuteError]
  def command(cmd, *opts, &block); end

  def command_lines(cmd, *opts); end

  # Takes the diff command line output (as Array) and parse it into a Hash
  #
  # @param diff_command [String] the diff commadn to be used
  # @param opts [Array] the diff options to be used
  # @return [Hash] the diff as Hash
  def diff_as_hash(diff_command, opts = T.unsafe(nil)); end

  def escape(s); end
  def escape_for_sh(s); end
  def escape_for_windows(s); end

  # Returns an array holding the common options for the log commands
  #
  # @param opts [Hash] the given options
  # @return [Array] the set of common options that the log command will use
  def log_common_options(opts); end

  # Retrurns an array holding path options for the log commands
  #
  # @param opts [Hash] the given options
  # @return [Array] the set of path options that the log command will use
  def log_path_options(opts); end

  # Takes the previously stored git's ENV variables and set them again on ENV.
  def restore_git_system_env_variables; end

  def run_command(git_cmd, &block); end

  # Sets git's ENV variables to the custom values for the current instance.
  def set_custom_git_env_variables; end

  # Takes the current git's system ENV variables and store them.
  def store_git_system_env_variables; end

  # @return [Boolean]
  def windows_platform?; end

  # Runs a block inside an environment with customized ENV variables.
  # It restores the ENV after execution.
  #
  # @param block [Proc] block to be executed within the customized environment
  def with_custom_env_variables(&block); end
end

# Systen ENV variables involved in the git commands.
#
# @return [<String>] the names of the EVN variables involved in the git commands
Git::Lib::ENV_VARIABLE_NAMES = T.let(T.unsafe(nil), Array)

# object that holds the last X commits on given branch
class Git::Log
  include ::Enumerable

  # @return [Log] a new instance of Log
  def initialize(base, count = T.unsafe(nil)); end

  def [](index); end
  def author(regex); end
  def between(sha1, sha2 = T.unsafe(nil)); end
  def cherry; end
  def each(&block); end
  def first; end
  def grep(regex); end
  def last; end
  def object(objectish); end
  def path(path); end
  def since(date); end

  # forces git log to run
  def size; end

  def skip(num); end
  def to_s; end
  def until(date); end

  private

  def check_log; end
  def dirty_log; end

  # actually run the 'git log' command
  def run_log; end
end

# represents a git object
class Git::Object
  class << self
    # if we're calling this, we don't know what type it is yet
    # so this is our little factory method
    def new(base, objectish, type = T.unsafe(nil), is_tag = T.unsafe(nil)); end
  end
end

class Git::Object::AbstractObject
  # @return [AbstractObject] a new instance of AbstractObject
  def initialize(base, objectish); end

  # creates an archive of this object (tree)
  def archive(file = T.unsafe(nil), opts = T.unsafe(nil)); end

  # @return [Boolean]
  def blob?; end

  # @return [Boolean]
  def commit?; end

  # Get the object's contents.
  # If no block is given, the contents are cached in memory and returned as a string.
  # If a block is given, it yields an IO object (via IO::popen) which could be used to
  # read a large file in chunks.
  #
  # Use this for large files so that they are not held in memory.
  def contents(&block); end

  def contents_array; end
  def diff(objectish); end
  def grep(string, path_limiter = T.unsafe(nil), opts = T.unsafe(nil)); end
  def log(count = T.unsafe(nil)); end

  # Returns the value of attribute mode.
  def mode; end

  # Sets the attribute mode
  #
  # @param value the value to set the attribute mode to.
  def mode=(_arg0); end

  # Returns the value of attribute objectish.
  def objectish; end

  # Sets the attribute objectish
  #
  # @param value the value to set the attribute objectish to.
  def objectish=(_arg0); end

  def sha; end
  def size; end

  # Sets the attribute size
  #
  # @param value the value to set the attribute size to.
  def size=(_arg0); end

  # @return [Boolean]
  def tag?; end

  def to_s; end

  # @return [Boolean]
  def tree?; end

  # Returns the value of attribute type.
  def type; end

  # Sets the attribute type
  #
  # @param value the value to set the attribute type to.
  def type=(_arg0); end
end

class Git::Object::Blob < ::Git::Object::AbstractObject
  # @return [Blob] a new instance of Blob
  def initialize(base, sha, mode = T.unsafe(nil)); end

  # @return [Boolean]
  def blob?; end
end

class Git::Object::Commit < ::Git::Object::AbstractObject
  # @return [Commit] a new instance of Commit
  def initialize(base, sha, init = T.unsafe(nil)); end

  # git author
  def author; end

  def author_date; end

  # @return [Boolean]
  def commit?; end

  # git author
  def committer; end

  def committer_date; end
  def date; end
  def diff_parent; end
  def gtree; end
  def message; end
  def name; end
  def parent; end

  # array of all parent commits
  def parents; end

  def set_commit(data); end

  private

  # see if this object has been initialized and do so if not
  def check_commit; end
end

class Git::Object::Tag < ::Git::Object::AbstractObject
  # @return [Tag] a new instance of Tag
  def initialize(base, sha, name); end

  # @return [Boolean]
  def annotated?; end

  def message; end

  # Returns the value of attribute name.
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  def name=(_arg0); end

  # @return [Boolean]
  def tag?; end

  def tagger; end

  private

  def check_tag; end
end

class Git::Object::Tree < ::Git::Object::AbstractObject
  # @return [Tree] a new instance of Tree
  def initialize(base, sha, mode = T.unsafe(nil)); end

  def blobs; end
  def children; end
  def depth; end
  def files; end
  def full_tree; end
  def subdirectories; end
  def subtrees; end

  # @return [Boolean]
  def tree?; end

  def trees; end

  private

  # actually run the git command
  def check_tree; end
end

class Git::Path
  # @return [Path] a new instance of Path
  def initialize(path, check_path = T.unsafe(nil)); end

  # Returns the value of attribute path.
  def path; end

  # Sets the attribute path
  #
  # @param value the value to set the attribute path to.
  def path=(_arg0); end

  # @return [Boolean]
  def readable?; end

  def to_s; end

  # @return [Boolean]
  def writable?; end
end

class Git::Remote < ::Git::Path
  # @return [Remote] a new instance of Remote
  def initialize(base, name); end

  def branch(branch = T.unsafe(nil)); end
  def fetch(opts = T.unsafe(nil)); end

  # Returns the value of attribute fetch_opts.
  def fetch_opts; end

  # Sets the attribute fetch_opts
  #
  # @param value the value to set the attribute fetch_opts to.
  def fetch_opts=(_arg0); end

  # merge this remote locally
  def merge(branch = T.unsafe(nil)); end

  # Returns the value of attribute name.
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  def name=(_arg0); end

  def remove; end
  def to_s; end

  # Returns the value of attribute url.
  def url; end

  # Sets the attribute url
  #
  # @param value the value to set the attribute url to.
  def url=(_arg0); end
end

class Git::Repository < ::Git::Path; end

class Git::Stash
  # @return [Stash] a new instance of Stash
  def initialize(base, message, existing = T.unsafe(nil)); end

  def message; end
  def save; end

  # @return [Boolean]
  def saved?; end

  def to_s; end
end

# object that holds all the available stashes
class Git::Stashes
  include ::Enumerable

  # @return [Stashes] a new instance of Stashes
  def initialize(base); end

  def [](index); end

  # Returns an multi-dimensional Array of elements that have been stash saved.
  # Array is based on position and name. See Example
  #
  # @example Returns Array of items that have been stashed
  #   .all - [0, "testing-stash-all"]]
  # @return [Array]
  def all; end

  def apply(index = T.unsafe(nil)); end
  def clear; end
  def each(&block); end
  def save(message); end
  def size; end
end

# A class for git status
class Git::Status
  include ::Enumerable

  # @return [Status] a new instance of Status
  def initialize(base); end

  # enumerable method
  def [](file); end

  # Returns an Enumerable containing files that have been added.
  # File path starts at git base directory
  #
  # @return [Enumerable]
  def added; end

  # Determines whether the given file has been added to the repository
  # File path starts at git base directory
  #
  # @example Check if lib/git.rb is added.
  #   added?('lib/git.rb')
  # @param file [String] The name of the file.
  # @return [Boolean]
  def added?(file); end

  # Returns an Enumerable containing files that have changed from the
  # git base directory
  #
  # @return [Enumerable]
  def changed; end

  # Determines whether the given file has been changed.
  # File path starts at git base directory
  #
  # @example Check if lib/git.rb has changed.
  #   changed?('lib/git.rb')
  # @param file [String] The name of the file.
  # @return [Boolean]
  def changed?(file); end

  # Returns an Enumerable containing files that have been deleted.
  # File path starts at git base directory
  #
  # @return [Enumerable]
  def deleted; end

  # Determines whether the given file has been deleted from the repository
  # File path starts at git base directory
  #
  # @example Check if lib/git.rb is deleted.
  #   deleted?('lib/git.rb')
  # @param file [String] The name of the file.
  # @return [Boolean]
  def deleted?(file); end

  def each(&block); end
  def pretty; end
  def pretty_file(file); end

  # Returns an Enumerable containing files that are not tracked in git.
  # File path starts at git base directory
  #
  # @return [Enumerable]
  def untracked; end

  # Determines whether the given file has is tracked by git.
  # File path starts at git base directory
  #
  # @example Check if lib/git.rb is an untracked file.
  #   untracked?('lib/git.rb')
  # @param file [String] The name of the file.
  # @return [Boolean]
  def untracked?(file); end

  private

  def construct_status; end
  def fetch_added; end
  def fetch_modified; end
  def fetch_untracked; end
end

# subclass that does heavy lifting
class Git::Status::StatusFile
  # @return [StatusFile] a new instance of StatusFile
  def initialize(base, hash); end

  def blob(type = T.unsafe(nil)); end

  # Returns the value of attribute mode_index.
  def mode_index; end

  # Sets the attribute mode_index
  #
  # @param value the value to set the attribute mode_index to.
  def mode_index=(_arg0); end

  # Returns the value of attribute mode_repo.
  def mode_repo; end

  # Sets the attribute mode_repo
  #
  # @param value the value to set the attribute mode_repo to.
  def mode_repo=(_arg0); end

  # Returns the value of attribute path.
  def path; end

  # Sets the attribute path
  #
  # @param value the value to set the attribute path to.
  def path=(_arg0); end

  # Returns the value of attribute sha_index.
  def sha_index; end

  # Sets the attribute sha_index
  #
  # @param value the value to set the attribute sha_index to.
  def sha_index=(_arg0); end

  # Returns the value of attribute sha_repo.
  def sha_repo; end

  # Sets the attribute sha_repo
  #
  # @param value the value to set the attribute sha_repo to.
  def sha_repo=(_arg0); end

  # Returns the value of attribute stage.
  def stage; end

  # Sets the attribute stage
  #
  # @param value the value to set the attribute stage to.
  def stage=(_arg0); end

  # Returns the value of attribute type.
  def type; end

  # Sets the attribute type
  #
  # @param value the value to set the attribute type to.
  def type=(_arg0); end

  # Returns the value of attribute untracked.
  def untracked; end

  # Sets the attribute untracked
  #
  # @param value the value to set the attribute untracked to.
  def untracked=(_arg0); end
end

# Methods for parsing a Git URL
#
# Any URL that can be passed to `git clone` can be parsed by this class.
#
# @api public
# @see https://git-scm.com/docs/git-clone#_git_urls GIT URLs
# @see https://github.com/sporkmonger/addressable Addresable::URI
class Git::URL
  class << self
    # The directory `git clone` would use for the repository directory for the given URL
    #
    # @api public
    # @example
    #   Git::URL.clone_to('https://github.com/ruby-git/ruby-git.git') #=> 'ruby-git'
    # @param url [String] the Git URL containing the repository directory
    # @return [String] the name of the repository directory
    def clone_to(url, bare: T.unsafe(nil), mirror: T.unsafe(nil)); end

    # Parse a Git URL and return an Addressable::URI object
    #
    # The URI returned can be converted back to a string with 'to_s'. This is
    # guaranteed to return the same URL string that was parsed.
    #
    # @api public
    # @example
    #   uri = Git::URL.parse('https://github.com/ruby-git/ruby-git.git')
    #   #=> #<Addressable::URI:0x44c URI:https://github.com/ruby-git/ruby-git.git>
    #   uri.scheme #=> "https"
    #   uri.host #=> "github.com"
    #   uri.path #=> "/ruby-git/ruby-git.git"
    #
    #   Git::URL.parse('/Users/James/projects/ruby-git')
    #   #=> #<Addressable::URI:0x438 URI:/Users/James/projects/ruby-git>
    # @param url [String] the Git URL to parse
    # @return [Addressable::URI] the parsed URI
    def parse(url); end
  end
end

# Regexp used to match a Git URL with an alternative SSH syntax
# such as `user@host:path`
#
# @api public
Git::URL::GIT_ALTERNATIVE_SSH_SYNTAX = T.let(T.unsafe(nil), Regexp)

# The current gem version
#
# @return [String] the current gem version.
Git::VERSION = T.let(T.unsafe(nil), String)

class Git::WorkingDirectory < ::Git::Path; end

class Git::Worktree < ::Git::Path
  # @return [Worktree] a new instance of Worktree
  def initialize(base, dir, gcommit = T.unsafe(nil)); end

  def add; end

  # Returns the value of attribute dir.
  def dir; end

  # Sets the attribute dir
  #
  # @param value the value to set the attribute dir to.
  def dir=(_arg0); end

  # Returns the value of attribute full.
  def full; end

  # Sets the attribute full
  #
  # @param value the value to set the attribute full to.
  def full=(_arg0); end

  # Returns the value of attribute gcommit.
  def gcommit; end

  # Sets the attribute gcommit
  #
  # @param value the value to set the attribute gcommit to.
  def gcommit=(_arg0); end

  def remove; end
  def to_a; end
  def to_s; end
end

# object that holds all the available worktrees
class Git::Worktrees
  include ::Enumerable

  # @return [Worktrees] a new instance of Worktrees
  def initialize(base); end

  def [](worktree_name); end
  def each(&block); end
  def prune; end

  # array like methods
  def size; end

  def to_s; end
end
